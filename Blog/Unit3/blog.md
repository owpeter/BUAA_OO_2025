# 测试过程

## 单元测试

单元测试的核心目标在于验证代码中最小可测试单元的行为是否符合预期。对于我们的作业来说，就是对每个方法进行测试，检查其行为是否在各方面均符合JML的规范。在进行单元测试的时候，应当确保隔离性，即确保测试失败仅仅是因为被测单元自身的问题，而非其他以来项的问题。

## 功能测试

功能测试的核心目的就是验证软件的各项功能是否按照需求规格说明书正确实现。 常是黑盒测试，测试人员不需要了解代码内部结构，只需根据需求文档设计测试用例，模拟用户操作，检查实际结果与预期结果是否一致。

## 集成测试

集成测试的目的是检测不同模块或服务在集成后，接口之间的数据交互、调用关系以及整体功能是否符合预期。测试过程中主要关注模块间的接口兼容性、数据在模块间的正确传递和转换、模块组合后是否引发新的错误等问题

## 压力测试

压力测试的核心目的是评估系统在极端或异常负载条件下的稳定性和可靠性。 它旨在找到系统的瓶颈和极限。通常使用自动化工具模拟大量并发用户或请求，持续增加负载，直到系统性能下降到不可接受的水平或出现故障。

## 回归测试

回归测试的目的就是在软件发生变更后，重新运行之前的测试用例，以确保这些变更没有引入新的缺陷或导致原有功能失效。 它是保证软件质量稳定性的重要防线。一般会选取一部分或全部已有的测试用例进行重新执行。自动化测试在回归测试中扮演着至关重要的角色，因为它能大大提高效率。

## 数据构造

在本单元中，我们可以通过评测机来够构建稠密图甚至完全图对我们的代码进行压力测试，通过手动构造边界数据进行边界测试。

# 大模型使用体验

本单元中我的代码实现基本由大模型辅助完成。我的感受是，大模型在理解JML方面有着较大的优势，我们可以借助大模型来帮助我们拆解那些较为复杂的JML规格描述。但如果直接使用大模型将JML翻译成代码，其生成的代码质量还是不够好的，主要不足在于对时间复杂度的优化方面。我们当然可以指导大模型，命令其优化所有复杂度大于$O(N^2)$的方法，但像`qtvs`这种需要较为复杂的逻辑才能进行优化的方法，大模型就难以胜任了。因此我们可以使用大模型来辅助我们进行设计与开发，但指望大模型完全替代我们完成作业，依然是不切实际的。

# 架构设计

与众多学长一样，本单元我也是采用林截图来构建图，并且大多使用`HashMap`数据结构来管理数据。至于对图本身的维护，我并没有额外的维护方法，而对于一些图的属性的维护，我将在性能部分提到，这里不再多说。

# 性能

本单元我出现的性能问题是有`qtvs`引发的，本以为$O(N^2)$的复杂度是可以接受的，并且助教也提到10s的限制应当可以接受$O(N^2logN)$的复杂度，但最终还是被卡了。我的修复策略也是比较朴素的，即对于每一个`tag`维护一个`valueSum`变量，在`att, ar, mr`方法中对该变量的值进行更新

至于规格与实现分离，这是很好理解的，毕竟JML的作用在于以一种极致严谨的方式表达一种需求，它不需要在意需求是如何被实现的，只需要确保需求描述的准确性即可，因此在具体实现时，肯定是需要我们采用更多良好的数据结构或算法进行优化的。

# 从JML到JUnit

- 对于`ensures`语句，应当检测方法被调用后是否按照语句的要求正确修改了状态
- 对于`old`，我们应当在调用被测方法前，使用深拷贝正确捕获所有相关的原始状态
- 对于`assignable`语句，JUnit应当检测那些不应该发生改变的状态是否真的没有被改变。