# 正向建模与开发

在第四单元前，我认为JML不过是一种可视化工具，其作用局限于让开发者向用户或产品经理讲解产品的功能，并不能正向的辅助我们进行开发。在写第一次作业的过程中我依然希望直接开始构建代码，而非通过UML引导我进行建模。但第二次作业新增的功能较为复杂，并且我发现，如果没有一个让人直观理解代码运作原理的东西，迭代开发的难度是较大的，因为你每次都需要理清一周前自己写的代码是如何跑起来的。因此，我开始尝试绘制一些不怎么标准的类图，构建起类与类之间的联系，搭起一个大致的框架后再开始具体的代码实现。我发现这样的步骤是非常合理的，构建草图的过程能够将我们从代码实现的繁复中解放出来，从一个宏观的视角对整个项目进行理解。

中国人思考问题总喜欢从宏观到微观，我认为从草图到代码就是这样一个过程，这也是我认为的，正向建模与开发的关系。但是我依然不习惯在敲代码前就绘制标准的UML类图，它太具体了，在绘制的过程中需要思考“每个类有什么属性，有什么方法，方法的参数有哪些，返回值是什么类型的...”等等非常多细碎的问题，想着想着就把人想晕了，个人认为在体感上和直接进行代码实现没有太大差别。

# 本单元架构设计

## 架构设计

![alt text](image-1.png)

- `main`：我在`main`中处理所有输入与输出，将命令解析后调用`Library`的相关方法进行处理
- `Library`：处理机制的核心，将请求进行拆分后传递给对应的“部门”进行处理
- 我设计了`Bookshelf, BorrowAndReturning, AppointmentOffice, ReadingRoom, PersonTable`这几个类，用于进行实现具体的业务逻辑
- `ApBook`：主要对`LibraryBookId`类进行了封装，添加了一些关于预约书籍的必要信息
- `BookAndSource`：也是对`LibraryBookId`进行封装，添加了来源书架信息，服务于第二次作业的热门书架功能

## 代码设计和UML模型设计之间的追踪关系

正如上文所说，我所理解的UML模型与代码之间的追踪关系应该是从宏观步进到微观的过程，利用UML模型快速构建起一个宏观层面的框架，之后再根据框架实现代码细节，对核心模块进行展开。

# 大模型运用

我目前经常使用的大模型为谷歌的Gemini pro，其在理解题目、代码实现等方面已经有足够强大的能力。但即便如此，直接将指导书发给他然后让它“按照以上要求完成这个项目”依然是不可取的。最好的办法就是将一个大的工程拆分成多个小的步骤，让AI一步一步的解决问题。

就以第四单元为例，我们可以尝试按以下步骤引导大模型构建一个完整的图书管理系统：
1. 把指导书传给它，并说：“根据指导书中关于题目要求的内容，帮我设计帮我为这次作业设计一个实现框架，告诉我需要设置几个类、每个类的作用
2. 以类为单位让AI实现代码
3. 将指导书与所有代码传给它，让它检查是否符合指导书中要求的逻辑

在每一个步骤中，当AI给出它的答案后我们都应该进行人工检查，指出其中不合理的地方让AI迭代改进。另外，在每个步骤完成后，可以让大模型进行反思与检查，如此能够显著提升模型最终生成内容的质量。例如步骤1中，我们可以让大模型“检查你设计的类是否符合封装、抽象、继承、多态的设计原则，是否将整个系统拆分为多个职责单一、高内聚、低耦合的类”。

当然，如果想要在强测中取得好成绩，免不了要自己人工check一遍，而且每次在检查的时候总还能查出一些奇奇怪怪的小bug，这也说明AI目前也仅仅是一个辅助的工具，想要靠AI 100%完成作业还是有困难的

# 四单元架构设计演进

架构设计能力是OO这门课带给我们最重要的东西，从第一单元设计表达式解析与计算时脑中的一团乱麻，到第二单元逐渐理清生产者消费者之间的关系，再到最后凭借UML类图在图书馆设计时“挥斥方遒”，可以说是一次历时16周的进化吧

- 第一单元的架构在设计上总的来说可以分为两部分：解析与计算。依靠递归下降的思想将表达式逐渐解析成一棵由`Expr, Term, Factor`结点组成的树，然后自底向上进行计算，将最底层的结点`toMono`转化成可计算的单项式`Mono`，再将多个单项式组合计算成为多项式`Poly`。
- 第二单元的主架构是典型的生产者-消费者模型，我设计了`InputHandler`用于接收输入请求并作为生产者，`Elevator`处理请求，为消费者。`Scheduler`作为调度器，存储了所有电梯的`RequestTable`对象，当请求到来时，将请求按照分配策略添加到对应电梯的请求表中，同时唤醒电梯进行消费。另外，我采用“电梯与运行策略分离”的设计。设置了策略类`Strategy`获得电梯当前的状态与其请求表的情况，运用“类LOOK”算法为电梯运行提供`Advice`枚举类中的一种。设置了`Person`类的设计是考虑到后续可能需要给请求增加一些信息，例如请求到达的时间、该人是否处于换乘状态、该人当前要前往的方向等。
- 第三单元比较特殊，它不需要我们亲自去设计架构，而是按照一个非常严谨的JML“需求文档”去进行具体的代码实现。这单元的主要收获就是，不要被JML的内容限制住了，一定要尽可能的优化优化再优化，JML只是提供了最基本的实现参考
- 第四单元的架构设计思路在上文已经说明了，这里不再赘述

# 四单元测试思路演进

我的测试思路基本上是固定的，基本上分为以下几个步骤：
- 静态debug，把比较明显的实现上的错误de掉
- 为评测机设计一些生成数据参数，指导评测机生成大量随机数据进行测试
- 手搓边界数据与极端数据

第三单元的强测有一个数据点让我见识到了什么叫真正的极端数据，之后我和同学尝试利用评测机随机出这样的数据，但以失败告终，这也提醒我们，基于随机数据的评测机往往并不能构造出非常极端的数据，是具有一定缺陷的，因此必要时还是应该手搓。

# 收获

我想OO带给我的收获，是远超于知识本身的。也许在多年后的某一个夏日的夜晚，我依然能想起那盯着评测机随机出来的让人摸不着头脑的数据，以及那AI都不想看的一千多行代码代码，发呆一下午试图找出神秘死锁bug的时光（。debug是痛苦的，刀人是快乐的，修bug是不甘的，但无论如何，我相信这一切的一切都将作为一份宝贵的经历，成为我今后学习、科研、工作的动力源泉。

最后提一嘴，OO这种连轴转的课程制度真的极大强化了我的结点意识，让我每天都清醒的知道今天是这学期第几周的第几天。