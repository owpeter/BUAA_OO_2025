import sympy as sp
import random

# 定义符号变量
x, y = sp.symbols('x y')

# 中心化配置
_CONFIG = {
    # 原有的配置项
    "coef_range": (-3, 3),
    "exponent_range": (0, 2),
    "trig_coef_range": (1, 3),
    "trig_offset_range": (-3, 3),
    "trig_power_range": (0, 3),
    "const_range": (-3, 3),
    
    "max_terms": 2,
    "max_sin_terms": 1,
    "max_cos_terms": 1,
    "max_n": 3,
    "max_depth": 2,
    
    "special_coef": [0, 1, -1],
    "special_exponent": [0, 1],
    "special_trig_coef": [1],
    "special_trig_offset": [0],
    "special_trig_power": [1, 0],
    "special_const": [0, 1, -1],
    "special_n": [0, 1, 2],
    "special_simple_expr": [0, 1, -1, 2, -2],
    
    "special_coef_prob": 0.4,
    "special_exponent_prob": 0.5,
    "special_trig_coef_prob": 0.5,
    "special_trig_offset_prob": 0.3,
    "special_trig_power_prob": 0.3,
    "special_const_prob": 0.6,
    "special_n_prob": 0.7,
    "special_expr_prob": 0.3,
    "simple_vs_complex_prob": 0.3,
    "add_constant_prob": 0.4,
    "simple_params_prob": 0.7,
    "single_term_prob": 0.6,
    "single_factor_prob": 0.7,
    "skip_nesting_prob": 0.5,
    
    # 已有的新增配置项：最终表达式生成相关
    "expr_types": ["basic_call", "call_with_term", "call_as_param", "composite"],
    "expr_weights": [0.5, 0.5, 0, 0],  # 各类表达式类型的权重
    "operations": ["+", "-", "*"],
    "operation_weights": [0.4, 0.4, 0.2],  # 运算符权重
    "trig_functions": ["sin", "cos"],
    "trig_function_weights": [0.5, 0.5],  # 三角函数权重
    "add_standard_term_prob": 0.5,  # 在复合表达式中添加标准项的概率
    "wrap_in_trig_prob": 0,      # 将整体表达式包装在三角函数中的概率
    
    # 新增配置项
    "x_expression_options": [
        "variable",           # 单独变量x
        "coef_variable",      # a*x
        "variable_power",     # x^n
        "variable_plus_const", # x+c
        "const"               # 纯常数
    ],
    "x_expression_weights": [0.3, 0.2, 0.2, 0.2, 0.1],  # 简单x表达式类型权重
    
    "non_zero_coef_prob": 0.7,     # 避免系数为0时，生成非零系数的概率
    "avoid_zero_coef_value": 1,    # 避免系数为0时使用的值
    
    # 递归函数定义相关
    "recursive_template": "f{{n}}(x,y) = {a} * f{{n-1}}(({g}), ({h})) + {b} * f{{n-2}}(({g_prime}), ({h_prime})) + {i}",
    
    # 错误处理
    "error_message": "符号计算出错: {error}"
}

# 辅助函数，生成带权重的随机整数
def weighted_random_int(min_val, max_val, special_values=None, special_weight=0.3):
    """
    生成一个随机整数，但对特殊值有更高的概率
    
    参数:
    - min_val, max_val: 整数范围
    - special_values: 特殊值列表，如[0, 1, -1]等
    - special_weight: 选择特殊值的概率
    """
    if special_values and random.random() < special_weight:
        return random.choice(special_values)
    return random.randint(min_val, max_val)

# 改进的复杂函数生成器
def generate_complex_expression(variable):
    """生成一个符合标准项形式的复杂符号表达式
    标准项形式: Σ(a * variable^b * Π(sin(expr_i)^c_i) * Π(cos(expr_i)^d_i))
    """
    # 决定项的数量
    num_terms = weighted_random_int(
        1, 
        _CONFIG["max_terms"], 
        [1], 
        _CONFIG["single_term_prob"]
    )
    terms = []
    
    for _ in range(num_terms):
        # 系数 - 增加特殊值的概率
        a = weighted_random_int(
            _CONFIG["coef_range"][0], 
            _CONFIG["coef_range"][1], 
            _CONFIG["special_coef"], 
            _CONFIG["special_coef_prob"]
        )
        if a == 0:  # 避免系数为0
            a = weighted_random_int(1, _CONFIG["coef_range"][1], [1], 0.7)
            
        # 指数 - 增加特殊值的概率
        b = weighted_random_int(
            _CONFIG["exponent_range"][0], 
            _CONFIG["exponent_range"][1], 
            _CONFIG["special_exponent"], 
            _CONFIG["special_exponent_prob"]
        )
        
        # sin项的数量
        num_sin_terms = weighted_random_int(
            0, 
            _CONFIG["max_sin_terms"], 
            [0, 1], 
            _CONFIG["single_factor_prob"]
        )
        sin_factors = []
        
        for _ in range(num_sin_terms):
            # 系数、偏移量和指数
            coef = weighted_random_int(
                _CONFIG["trig_coef_range"][0], 
                _CONFIG["trig_coef_range"][1], 
                _CONFIG["special_trig_coef"], 
                _CONFIG["special_trig_coef_prob"]
            )
            offset = weighted_random_int(
                _CONFIG["trig_offset_range"][0], 
                _CONFIG["trig_offset_range"][1], 
                _CONFIG["special_trig_offset"], 
                _CONFIG["special_trig_offset_prob"]
            )
            power = weighted_random_int(
                _CONFIG["trig_power_range"][0], 
                _CONFIG["trig_power_range"][1], 
                _CONFIG["special_trig_power"], 
                _CONFIG["special_trig_power_prob"]
            )
            sin_expr = sp.sin(coef * variable + offset) ** power
            sin_factors.append(sin_expr)
        
        # cos项的数量
        num_cos_terms = weighted_random_int(
            0, 
            _CONFIG["max_cos_terms"], 
            [0, 1], 
            _CONFIG["single_factor_prob"]
        )
        cos_factors = []
        
        for _ in range(num_cos_terms):
            # 系数、偏移量和指数
            coef = weighted_random_int(
                _CONFIG["trig_coef_range"][0], 
                _CONFIG["trig_coef_range"][1], 
                _CONFIG["special_trig_coef"], 
                _CONFIG["special_trig_coef_prob"]
            )
            offset = weighted_random_int(
                _CONFIG["trig_offset_range"][0], 
                _CONFIG["trig_offset_range"][1], 
                _CONFIG["special_trig_offset"], 
                _CONFIG["special_trig_offset_prob"]
            )
            power = weighted_random_int(
                _CONFIG["trig_power_range"][0], 
                _CONFIG["trig_power_range"][1], 
                _CONFIG["special_trig_power"], 
                _CONFIG["special_trig_power_prob"]
            )
            cos_expr = sp.cos(coef * variable + offset) ** power
            cos_factors.append(cos_expr)
        
        # 构建完整项
        term = a * (variable ** b)
        
        # 乘以所有sin因子
        for factor in sin_factors:
            term *= factor
            
        # 乘以所有cos因子
        for factor in cos_factors:
            term *= factor
            
        terms.append(term)
    
    # 合并所有项
    expression = 0
    for term in terms:
        expression += term
        
    return expression

# 定义递推函数的符号表示类
class RecursiveCall:
    def __init__(self, n, x_expr, y_expr):
        self.n = n
        self.x_expr = x_expr
        self.y_expr = y_expr
    
    def __str__(self):
        return f"f{{{self.n}}}(({self.x_expr}), ({self.y_expr}))"
    
    def __repr__(self):
        return self.__str__()

# 改进的X表达式生成器
def generate_x_expression(complexity=1):
    """生成关于x的表达式，complexity控制复杂度"""
    if complexity <= 0 or random.random() < _CONFIG["simple_vs_complex_prob"]:
        # 简单表达式 - 使用配置定义的选项
        expr_type = random.choices(
            _CONFIG["x_expression_options"],
            weights=_CONFIG["x_expression_weights"],
            k=1
        )[0]
        
        if expr_type == "variable":
            return x
        elif expr_type == "coef_variable":
            return weighted_random_int(1, _CONFIG["coef_range"][1], [1, 2], _CONFIG["special_coef_prob"]) * x
        elif expr_type == "variable_power":
            return x**weighted_random_int(1, _CONFIG["exponent_range"][1], [1, 2], _CONFIG["special_exponent_prob"])
        elif expr_type == "variable_plus_const":
            return x + weighted_random_int(_CONFIG["const_range"][0], _CONFIG["const_range"][1], 
                                   _CONFIG["special_const"], _CONFIG["special_const_prob"])
        else:  # const
            return weighted_random_int(_CONFIG["const_range"][0], _CONFIG["const_range"][1], 
                              _CONFIG["special_const"], _CONFIG["special_const_prob"])
    else:
        # 复杂表达式 - 移除复杂的分数和指数，遵循标准项形式
        expr_options = [
            x ** weighted_random_int(
                _CONFIG["exponent_range"][0], 
                _CONFIG["exponent_range"][1], 
                _CONFIG["special_exponent"], 
                _CONFIG["special_exponent_prob"]
            ),
            weighted_random_int(
                1, 
                _CONFIG["coef_range"][1], 
                [1], 
                _CONFIG["special_coef_prob"]
            ) * x,
            sp.sin(
                weighted_random_int(
                    _CONFIG["trig_coef_range"][0], 
                    _CONFIG["trig_coef_range"][1], 
                    _CONFIG["special_trig_coef"], 
                    _CONFIG["special_trig_coef_prob"]
                ) * x + 
                weighted_random_int(
                    _CONFIG["trig_offset_range"][0], 
                    _CONFIG["trig_offset_range"][1], 
                    _CONFIG["special_trig_offset"], 
                    _CONFIG["special_trig_offset_prob"]
                )
            ),
            sp.cos(
                weighted_random_int(
                    _CONFIG["trig_coef_range"][0], 
                    _CONFIG["trig_coef_range"][1], 
                    _CONFIG["special_trig_coef"], 
                    _CONFIG["special_trig_coef_prob"]
                ) * x + 
                weighted_random_int(
                    _CONFIG["trig_offset_range"][0], 
                    _CONFIG["trig_offset_range"][1], 
                    _CONFIG["special_trig_offset"], 
                    _CONFIG["special_trig_offset_prob"]
                )
            )
        ]
        
        # 随机选择1-2个表达式相乘
        num_factors = weighted_random_int(
            1, 
            2, 
            [1], 
            _CONFIG["single_factor_prob"]
        )
        result = 1
        for _ in range(num_factors):
            factor = random.choice(expr_options)
            result *= factor
            
        # 加上一个常数的概率
        if random.random() < _CONFIG["add_constant_prob"]:
            result += weighted_random_int(
                _CONFIG["const_range"][0], 
                _CONFIG["const_range"][1], 
                _CONFIG["special_const"], 
                _CONFIG["special_const_prob"]
            )
            
        return result

# 嵌套函数调用生成器
def generate_nested_call(n, max_depth=2):
    """
    生成嵌套递推函数调用，返回RecursiveCall对象
    """
    # 增加直接返回基础表达式的概率
    if max_depth == 0 or random.random() > _CONFIG["skip_nesting_prob"]:
        # 一定概率直接返回x或特殊表达式
        if random.random() < _CONFIG["special_expr_prob"]:
            special_exprs = [x] + _CONFIG["special_simple_expr"]
            return random.choice(special_exprs)
        else:
            return generate_x_expression()
    
    # 嵌套递推函数调用
    # 增加边界情况n=0和n=1的概率
    nested_n = weighted_random_int(
        0, 
        max(n - 1, 1), 
        _CONFIG["special_n"], 
        _CONFIG["special_n_prob"]
    )
    
    # 增加简单参数的概率
    if random.random() < _CONFIG["simple_params_prob"]:
        # 一定概率使用特殊简单参数
        special_params = [x] + _CONFIG["special_simple_expr"]
        x_nested = random.choice(special_params)
        y_nested = random.choice(special_params)
    else:
        # 正常生成嵌套调用
        x_nested = generate_nested_call(nested_n, max_depth - 1)
        y_nested = generate_nested_call(nested_n, max_depth - 1)
    
    return RecursiveCall(nested_n, x_nested, y_nested)

# 定义递推函数实际计算
# 定义递推函数实际计算
def recursive_function(n, x_expr, y_expr):
    """
    实现递推关系计算：
    f_n(x, y) = a * f_{n-1}(g(x, y), h(x, y)) + b * f_{n-2}(g'(x, y), h'(x, y)) + i(x, y)
    """
    if n == 0:
        return f0.subs({x: x_expr, y: y_expr})
    elif n == 1:
        return f1.subs({x: x_expr, y: y_expr})
    else:
        # 递归调用
        f_n_minus_1 = recursive_function(
            n - 1,
            g.subs({x: x_expr, y: y_expr}),
            h.subs({x: x_expr, y: y_expr}),
        )
        f_n_minus_2 = recursive_function(
            n - 2,
            g_prime.subs({x: x_expr, y: y_expr}),
            h_prime.subs({x: x_expr, y: y_expr}),
        )
        return a * f_n_minus_1 + b * f_n_minus_2 + i.subs({x: x_expr})

# 符号计算函数
def evaluate_symbolic(expr):
    """进行符号计算，保持表达式形式"""
    if isinstance(expr, RecursiveCall):
        x_result = evaluate_symbolic(expr.x_expr)
        y_result = evaluate_symbolic(expr.y_expr)
        return recursive_function(expr.n, x_result, y_result)
    else:
        return expr
    
# 添加在evaluate_symbolic函数后面
def generate_final_expression():
    """
    生成最终表达式，可能包含递推函数调用和复杂表达式的组合
    """
    # 生成一个递推函数调用
    n = weighted_random_int(
        2, 
        _CONFIG["max_n"], 
        _CONFIG["special_n"], 
        _CONFIG["special_n_prob"]
    )
    
    max_depth = weighted_random_int(
        1, 
        _CONFIG["max_depth"], 
        [1], 
        _CONFIG["single_factor_prob"]
    )
    
    x_expr = generate_nested_call(n, max_depth=max_depth)
    y_expr = generate_nested_call(n, max_depth=max_depth)
    recursive_call = RecursiveCall(n, x_expr, y_expr)
    
    # 根据权重决定最终表达式的类型
    expr_type = random.choices(
        _CONFIG["expr_types"],
        weights=_CONFIG["expr_weights"],
        k=1
    )[0]
    
    if expr_type == "basic_call":
        return {
            "expression_str": str(recursive_call),
            "call": recursive_call,
            "type": "basic_call"
        }
    
    elif expr_type == "call_with_term":
        # 递推函数调用与标准项表达式结合
        operation = random.choices(
            _CONFIG["operations"],
            weights=_CONFIG["operation_weights"],
            k=1
        )[0]
        standard_expr = generate_complex_expression(x)
        
        expr_str = f"{recursive_call} {operation} {standard_expr}"
        return {
            "expression_str": expr_str,
            "call": recursive_call, 
            "operation": operation, 
            "standard_expr": standard_expr,
            "type": "call_with_term"
        }
    
    elif expr_type == "call_as_param":
        # 将递推函数调用嵌入三角函数
        trig_func = random.choices(
            _CONFIG["trig_functions"],
            weights=_CONFIG["trig_function_weights"],
            k=1
        )[0]
        power = weighted_random_int(
            1, 
            _CONFIG["trig_power_range"][1], 
            _CONFIG["special_trig_power"], 
            _CONFIG["special_trig_power_prob"]
        )
        
        expr_str = f"{trig_func}(({recursive_call}))^{power}"
        return {
            "expression_str": expr_str,
            "call": recursive_call,
            "trig_func": trig_func,
            "power": power,
            "type": "call_as_param"
        }
    
    else:  # "composite"
        # 创建更复杂的组合表达式
        composite_parts = []
        
        # 添加递推函数调用
        composite_parts.append(recursive_call)
        
        # 根据配置添加标准项表达式
        if random.random() < _CONFIG["add_standard_term_prob"]:
            operation = random.choices(
                _CONFIG["operations"],
                weights=_CONFIG["operation_weights"],
                k=1
            )[0]
            standard_expr = generate_complex_expression(x)
            composite_parts.append((operation, standard_expr))
        
        # 构建内部表达式字符串
        inner_expr = str(composite_parts[0])
        for op, expr in composite_parts[1:]:
            inner_expr += f" {op} {expr}"
        
        # 根据配置可能将整体嵌入到三角函数
        if random.random() < _CONFIG["wrap_in_trig_prob"]:
            trig_func = random.choices(
                _CONFIG["trig_functions"],
                weights=_CONFIG["trig_function_weights"],
                k=1
            )[0]
            power = weighted_random_int(
                1, 
                _CONFIG["trig_power_range"][1], 
                _CONFIG["special_trig_power"], 
                _CONFIG["special_trig_power_prob"]
            )
            
            expr_str = f"{trig_func}(({inner_expr}))^{power}"
            return {
                "expression_str": expr_str,
                "composite_parts": composite_parts, 
                "trig_func": trig_func, 
                "power": power,
                "type": "composite_trig"
            }
        else:
            # 不使用三角函数，直接构建复合表达式
            return {
                "expression_str": inner_expr,
                "parts": composite_parts,
                "type": "composite"
            }

# 主函数，用于生成和求解递推式问题
def generate_recursive_problem():
    # 定义递推关系中的函数
    global g, h, g_prime, h_prime, i, f0, f1, a, b
    
    g = generate_complex_expression(x)
    h = generate_complex_expression(y)
    g_prime = generate_complex_expression(x)
    h_prime = generate_complex_expression(y)
    i = generate_complex_expression(x)
    # 定义初始条件
    f0 = generate_complex_expression(x) + generate_complex_expression(y)
    f1 = generate_complex_expression(x) * generate_complex_expression(y)
    # 随机生成系数，增加特殊值的概率
    a = weighted_random_int(
        _CONFIG["coef_range"][0], 
        _CONFIG["coef_range"][1], 
        _CONFIG["special_coef"], 
        _CONFIG["special_coef_prob"]
    )
    if a == 0:  # 避免系数为0
        a = weighted_random_int(1, _CONFIG["coef_range"][1], 
                               [_CONFIG["avoid_zero_coef_value"]], 
                               _CONFIG["non_zero_coef_prob"])
        
    b = weighted_random_int(
        _CONFIG["coef_range"][0], 
        _CONFIG["coef_range"][1], 
        _CONFIG["special_coef"], 
        _CONFIG["special_coef_prob"]
    )
    if b == 0:  # 避免系数为0
        b = weighted_random_int(1, _CONFIG["coef_range"][1], 
                               [_CONFIG["avoid_zero_coef_value"]], 
                               _CONFIG["non_zero_coef_prob"])
    
    n = weighted_random_int(
        2, 
        _CONFIG["max_n"], 
        _CONFIG["special_n"], 
        _CONFIG["special_n_prob"]
    )
    
    max_depth = weighted_random_int(
        1, 
        _CONFIG["max_depth"], 
        [1], 
        _CONFIG["single_factor_prob"]
    )
    final_expression = generate_final_expression()
    
    # 符号计算
    try:
        # 区分不同类型的表达式并计算结果
        expr_type = final_expression["type"]
        
        if expr_type == "basic_call":
            symbolic_result = evaluate_symbolic(final_expression["call"])
        
        elif expr_type == "call_with_term":
            recursive_result = evaluate_symbolic(final_expression["call"])
            operation = final_expression["operation"]
            standard_expr = final_expression["standard_expr"]
            
            if operation == "+":
                symbolic_result = recursive_result + standard_expr
            elif operation == "-":
                symbolic_result = recursive_result - standard_expr
            else:  # "*"
                symbolic_result = recursive_result * standard_expr
        
        elif expr_type == "call_as_param":
            recursive_result = evaluate_symbolic(final_expression["call"])
            trig_func = final_expression["trig_func"]
            power = final_expression["power"]
            
            if trig_func == "sin":
                symbolic_result = sp.sin(recursive_result) ** power
            else:  # "cos"
                symbolic_result = sp.cos(recursive_result) ** power
        
        elif expr_type == "composite":
            # 处理复合表达式
            parts = final_expression["parts"]
            if isinstance(parts[0], RecursiveCall):
                result = evaluate_symbolic(parts[0])
            else:
                result = parts[0]
            
            for i in range(1, len(parts)):
                op, expr = parts[i]
                if isinstance(expr, RecursiveCall):
                    expr_result = evaluate_symbolic(expr)
                else:
                    expr_result = expr
                
                if op == "+":
                    result += expr_result
                elif op == "-":
                    result -= expr_result
                else:  # "*"
                    result *= expr_result
            
            symbolic_result = result
        
        elif expr_type == "composite_trig":
            # 处理带三角函数的复合表达式
            parts = final_expression["composite_parts"]
            if isinstance(parts[0], RecursiveCall):
                result = evaluate_symbolic(parts[0])
            else:
                result = parts[0]
            
            for i in range(1, len(parts)):
                op, expr = parts[i]
                if isinstance(expr, RecursiveCall):
                    expr_result = evaluate_symbolic(expr)
                else:
                    expr_result = expr
                
                if op == "+":
                    result += expr_result
                elif op == "-":
                    result -= expr_result
                else:  # "*"
                    result *= expr_result
            
            trig_func = final_expression["trig_func"]
            power = final_expression["power"]
            
            if trig_func == "sin":
                symbolic_result = sp.sin(result) ** power
            else:  # "cos"
                symbolic_result = sp.cos(result) ** power
        
        else:
            symbolic_result = "无法识别的表达式类型"
            
        return {
            "definition": {
                "f0": f0,
                "f1": f1,
                "recursive_relation": _CONFIG["recursive_template"].format(
                    a=a, g=g, h=h, b=b, g_prime=g_prime, h_prime=h_prime, i=i)
            },
            "expression": final_expression["expression_str"],  # 统一返回字符串形式的表达式
            "expression_details": final_expression,  # 保留完整的表达式结构信息
            "result": symbolic_result
        }
    except Exception as e:
        print(_CONFIG["error_message"].format(error=e))
        return {
            "definition": {
                "f0": f0,
                "f1": f1,
                "recursive_relation": _CONFIG["recursive_template"].format(
                    a=a, g=g, h=h, b=b, g_prime=g_prime, h_prime=h_prime, i=i)
            },
            "expression": final_expression["expression_str"],
            "expression_details": final_expression,
            "result": f"计算出错: {str(e)}"
        }

# 允许调整配置参数的函数
def update_config(new_config):
    """
    更新配置参数
    
    参数:
    - new_config: 包含需要更新的配置项的字典
    """
    global _CONFIG
    for key, value in new_config.items():
        if key in _CONFIG:
            _CONFIG[key] = value
        else:
            print(f"警告: 配置项 '{key}' 不存在，将被忽略")

# 如果直接运行这个脚本
if __name__ == "__main__":
    # 可选: 在这里调整配置参数
    # 例如，如果想要更简单的表达式:
    # update_config({
    #     "max_terms": 1,
    #     "max_sin_terms": 1,
    #     "max_cos_terms": 1,
    #     "max_depth": 1,
    #     "simple_vs_complex_prob": 0.7
    # })
    
    # 生成问题
    for _ in range(100):
        problem = generate_recursive_problem()
    
    # 如果需要，可以进一步处理 problem 字典
