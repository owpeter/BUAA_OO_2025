需要控制：电梯上下行，电梯开关门，乘客进出电梯

系统运行中乘客可以中途下电梯，系统结束时到达目的地即可

（本次作业）乘客只能进入和离开输入时指定的电梯，不可以进入其他电梯

不出现起点层和终点层相同的乘客请求。

# 策略类

首先为电梯规定一个初始方向，然后电梯开始沿着该方向运动。

到达某楼层时，首先判断是否需要开门
- 如果发现电梯里有人可以出电梯（到达目的地），则开门让乘客出去；
- 如果发现该楼层中有人想上电梯，并且目的地方向和电梯方向相同，则开门让这个乘客进入。

接下来，进一步判断电梯里是否有人。
- 如果电梯里还有人，则沿着当前方向移动到下一层。
- 如果电梯里没人，检查请求队列中是否还有请求（目前其他楼层是否有乘客想要进电梯）——
    - 如果请求队列不为空，且某请求的发出地是电梯"前方"的某楼层，则电梯继续沿着原来的方向运动。
    - 如果请求队列不为空，且所有请求的发出地都在电梯"后方"的楼层上，或者是在该楼层有请求但是这个请求的目的地在电梯后方（因为电梯不会开门接反方向的请求），则电梯掉头并进入"判断是否需要开门"的步骤（循环实现）。
    - 计算后方总权重，如果后方总权重 + 1.5(?) > 前方权重，那么掉头

$$
weight = \sum (\frac{w_i}{d_i} - \gamma)
$$


这段代码实现了一个电梯调度系统的逻辑，主要用于模拟电梯的运行过程。以下是代码的主要逻辑分解和解释：

---

### 1. **类和属性**
- **`Elevator` 类**：
  - 表示一个电梯对象，包含电梯的状态、运行参数（如移动间隔、门开关间隔）、乘客列表、请求队列等。
  - 使用了多种数据结构来管理电梯的状态和操作，例如：
    - `requests`：存储等待进入电梯的请求。
    - `passengers`：存储当前在电梯内的乘客。
    - `operations`：记录电梯的操作序列（如开门、关门、到达某层等）。

- **关键属性**：
  - `status`：电梯门的状态（打开或关闭）。
  - `moveGap` 和 `doorGap`：分别表示电梯移动和开关门的时间间隔。
  - `capacity`：电梯的最大载客量。
  - `location`：电梯当前所在的楼层。
  - `arriveTime`：记录每个乘客进入电梯的时间戳，用于计算总等待时间。

---

### 2. **核心方法**
#### **(1) 构造函数**
- 提供了两个构造函数：
  - 主构造函数用于初始化电梯的基本状态。
  - 深拷贝构造函数用于克隆电梯对象，方便模拟不同方向的运行。

#### **(2) `addRequest` 方法**
- 添加新的乘客请求到 `requests` 列表中，并记录请求的时间戳。
- 调用 `rescheduleRequests` 方法重新规划电梯的运行路径。

#### **(3) `rescheduleRequests` 方法**
- 通过克隆电梯对象，分别模拟向上和向下运行的两种情况。
- 根据模拟结果选择最优的运行方向（基于时间和优先级的加权计算）。

#### **(4) `simulate` 方法**
- 模拟电梯的运行过程，生成一系列操作（如到达某层、开门、关门等）。   
- 主要逻辑包括：
  - 根据当前方向和楼层限制调整电梯的运行方向。
  - 处理乘客离开和进入电梯的逻辑。
  - 确保电梯门的开关和移动时间间隔符合设定值。

#### **(5) `simulateLeave` 和 `simulateJoin` 方法**
- **`simulateLeave`**：
  - 检查当前楼层是否有乘客需要离开电梯。
  - 如果有，则生成开门和离开操作。
- **`simulateJoin`**：
  - 检查当前楼层是否有乘客需要进入电梯。
  - 根据电梯的剩余容量和运行方向决定是否允许乘客进入。

#### **(6) `open`, `close`, `arrive`, `in`, `out` 方法**
- 这些方法分别对应电梯的具体操作：
  - 开门、关门、到达某层、乘客进入、乘客离开。
  - 每个方法都包含状态检查，确保操作的合法性（如不能在门关闭时让乘客进入）。

#### **(7) `fixTimeStamp` 方法**
- 调整操作序列中的时间戳，确保电梯的操作时间间隔符合设定值（如移动间隔和开关门间隔）。

---

### 3. **辅助类和枚举**
- **`ElevatorStatus` 枚举**：
  - 定义了电梯门的状态（打开或关闭）。
- **`Operation` 及其子类**：
  - 表示电梯的操作（如 `OpenOperation`、`CloseOperation`、`ArriveOperation` 等）。
  - 每个操作都包含时间戳和具体的操作内容。

---

### 4. **逻辑流程**
1. **初始化**：
   - 创建电梯对象，设置初始状态和参数。
2. **接收请求**：
   - 调用 `addRequest` 方法添加乘客请求。
3. **重新规划路径**：
   - 调用 `rescheduleRequests` 方法，根据当前请求和乘客状态选择最优运行方向。
4. **模拟运行**：
   - 调用 `simulate` 方法生成电梯的操作序列。
   - 在模拟过程中处理乘客的进入和离开。
5. **执行操作**：
   - 根据生成的操作序列，依次执行开门、关门、移动等操作。
6. **调整时间戳**：
   - 调用 `fixTimeStamp` 方法确保操作时间间隔符合设定值。

---

### 5. **应用场景**
- 该代码适用于模拟多层建筑中的电梯调度系统。
- 支持动态添加乘客请求，并根据优先级和时间优化电梯的运行路径。
- 可用于研究电梯调度算法的性能和效率。

---

### 6. **总结**
这段代码通过面向对象的设计实现了电梯调度的核心逻辑，涵盖了从请求处理到操作执行的完整流程。代码结构清晰，逻辑严谨，适合进一步扩展和优化。

---


这段代码是 `Elevator` 类中 `simulate` 方法的核心逻辑，用于模拟电梯的运行过程。以下是对其逻辑的详细总结：

---

### **1. 初始化**
- **清空操作序列**：
  ```java
  operations.clear();
  ```

  每次模拟开始时，清空之前的操作记录，确保新的模拟结果不会受到旧数据的影响。
  
- **初始化时间戳和方向**：
  ```java
  long timeStamp = startTimeStamp;
  int direction = startDirection;
  ```

  - `timeStamp` 表示当前模拟的时间点，初始值为 `startTimeStamp`。
  - `direction` 表示电梯的运行方向（`1` 表示向上，`-1` 表示向下），初始值为 `startDirection`。

---

### **2. 主循环**
主循环的条件是 `requests` 或 `passengers` 不为空，即电梯还有未处理的请求或乘客未到达目的地。

#### **(1) 调整运行方向**
```java
if (direction == -1 && location == 0) {
    direction = 1;
} else if (direction == 1 && location == Floor.values().length - 1) {
    direction = -1;
}
```

- 如果电梯运行到最低层（`location == 0`）且方向向下，则将方向调整为向上。
- 如果电梯运行到最高层（`location == Floor.values().length - 1`）且方向向上，则将方向调整为向下。
- 这段逻辑确保电梯在到达边界楼层时能够正确转向。

#### **(2) 处理乘客离开**
```java
if (!passengers.isEmpty()) {
    simulateLeave(timeStamp);
}
```

- 调用 `simulateLeave` 方法，检查当前楼层是否有乘客需要离开电梯。
- 如果有乘客需要离开，则生成开门和离开操作，并更新相关状态。

#### **(3) 处理乘客进入**
```java
if (passengers.size() < capacity) {
    direction = simulateJoin(timeStamp, direction);
}
```

- 调用 `simulateJoin` 方法，检查当前楼层是否有乘客需要进入电梯。
- 根据电梯的剩余容量和运行方向决定是否允许乘客进入。
- 如果允许乘客进入，则生成开门和进入操作，并更新相关状态。
- 返回值 `direction` 可能会被修改，表示电梯的运行方向可能因乘客请求而改变。

#### **(4) 关门操作**
```java
if (status == ElevatorStatus.DOOR_OPEN) {
    long gap = timeStamp - lastOpen;
    if (gap < doorGap) {
        timeStamp += doorGap - gap;
    }
    operations.add(new CloseOperation(timeStamp, this));
    close(timeStamp);
}
```

- 如果电梯门处于打开状态，则需要执行关门操作。
- 确保关门操作的时间间隔（`doorGap`）符合设定值。
- 将关门操作添加到操作序列中，并调用 `close` 方法更新电梯状态。

#### **(5) 检查结束条件**
```java
if (requests.isEmpty() && passengers.isEmpty()) {
    break;
}
```

- 如果没有未处理的请求且电梯内没有乘客，则退出循环，模拟结束。

#### **(6) 移动到下一层**
```java
long gap = timeStamp - Math.max(lastArrive, lastClose);
if (gap < moveGap) {
    timeStamp += moveGap - gap;
}
operations.add(new ArriveOperation(timeStamp, location + direction));
arrive(timeStamp, location + direction);
```

- 确保电梯移动的时间间隔（`moveGap`）符合设定值。
- 将到达下一层的操作添加到操作序列中，并调用 `arrive` 方法更新电梯的位置。

---

### **3. 返回值**
```java
return timeStamp;
```

- 返回模拟结束时的时间戳，表示电梯完成所有操作所需的总时间。

---

### **4. 逻辑流程总结**
1. **初始化**：
   - 清空操作序列，设置初始时间戳和运行方向。
2. **主循环**：
   - 调整运行方向，确保电梯在边界楼层正确转向。
   - 处理乘客离开：检查当前楼层是否有乘客需要离开电梯。
   - 处理乘客进入：根据容量和方向决定是否允许乘客进入电梯。
   - 执行关门操作：确保关门时间间隔符合设定值。
   - 检查结束条件：如果没有未处理的请求且电梯内没有乘客，则退出循环。
   - 移动到下一层：确保移动时间间隔符合设定值，并更新电梯位置。
3. **返回结果**：
   - 返回模拟结束时的时间戳。

---

### **5. 应用场景**
- 这段代码主要用于模拟电梯的运行过程，生成一系列操作（如到达某层、开门、关门等）。
- 它通过动态调整运行方向和处理乘客请求，优化了电梯的调度效率。
- 可用于研究电梯调度算法的性能和效率。

---

### **6. 总结**
这段代码实现了电梯运行的核心逻辑，涵盖了从方向调整到乘客处理、再到移动和开关门的完整流程。代码结构清晰，逻辑严谨，适合进一步扩展和优化。